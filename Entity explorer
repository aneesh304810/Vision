"""
========================================================
ENTITY MODEL EXPLORER - Modular Component
========================================================
Can be imported and used by main Data Explorer
or run standalone

Features:
- Load Entity Model Reference Excel
- Entity Relationship Diagrams
- Field-level lineage (Source â†’ DW)
- Search entities and fields
- Cross-reference with interfaces
========================================================
"""

import streamlit as st
import pandas as pd
import os
from collections import defaultdict

# Visualization
try:
    import plotly.graph_objects as go
    import networkx as nx
    PLOTLY_AVAILABLE = True
except:
    PLOTLY_AVAILABLE = False

# ========================================================
# UTILITY FUNCTIONS
# ========================================================

def clean_column_name(col):
    """Clean column names for consistent access"""
    return str(col).strip().lower().replace(" ", "_").replace("/", "_").replace("-", "_").replace("(", "").replace(")", "").strip("_")

def safe_get(row, column, default=""):
    """Safely get value from row"""
    try:
        val = row.get(column, default) if isinstance(row, dict) else getattr(row, column, default)
        return val if pd.notna(val) and str(val) != 'nan' and str(val) != '' else default
    except:
        return default

# ========================================================
# ENTITY MODEL LOADER
# ========================================================

def load_entity_model_reference(file):
    """
    Load Entity Model Reference Excel
    
    Expected structure:
    - Sheet 1: "Entity Matrix" - List of all entities and relationships
    - Other Sheets: Individual entity models (e.g., "Account", "Transaction")
      - Columns: Source Field, Field Description, DW Column Name (or similar)
    
    Returns:
        entity_matrix_df: DataFrame with entity matrix
        entity_models: Dict of {entity_name: DataFrame with field mappings}
    """
    
    st.info("ðŸ“š Loading Entity Model Reference...")
    
    try:
        # Read all sheet names
        excel_file = pd.ExcelFile(file)
        sheet_names = excel_file.sheet_names
        
        st.write(f"âœ… Found {len(sheet_names)} sheets")
        
        # First sheet is Entity Matrix
        entity_matrix = None
        matrix_sheet_name = None
        
        for sheet in ["Entity Matrix", "entity matrix", "Matrix", "matrix", "Sheet1"]:
            if sheet in sheet_names:
                entity_matrix = pd.read_excel(file, sheet_name=sheet)
                matrix_sheet_name = sheet
                st.success(f"âœ… Loaded Entity Matrix from sheet: '{sheet}'")
                break
        
        if entity_matrix is None:
            # Use first sheet
            entity_matrix = pd.read_excel(file, sheet_name=0)
            matrix_sheet_name = sheet_names[0]
            st.info(f"â„¹ï¸ Using first sheet as Entity Matrix: '{matrix_sheet_name}'")
        
        # Clean entity matrix
        entity_matrix.columns = [clean_column_name(col) for col in entity_matrix.columns]
        entity_matrix = entity_matrix.dropna(axis=1, how='all')
        entity_matrix = entity_matrix.loc[:, ~entity_matrix.columns.str.contains("^unnamed", case=False)]
        
        # Show detected columns
        with st.expander("ðŸ“‹ Entity Matrix Columns Detected", expanded=False):
            st.write("Columns found:", list(entity_matrix.columns))
            st.write(f"Rows: {len(entity_matrix)}")
        
        # Load all other sheets as entity models
        entity_models = {}
        
        for sheet_name in sheet_names:
            # Skip the matrix sheet
            if sheet_name == matrix_sheet_name:
                continue
                
            try:
                df = pd.read_excel(file, sheet_name=sheet_name)
                
                # Clean columns
                df.columns = [clean_column_name(col) for col in df.columns]
                df = df.dropna(axis=1, how='all')
                df = df.loc[:, ~df.columns.str.contains("^unnamed", case=False)]
                
                # Remove empty rows
                df = df.dropna(how='all')
                
                # Clean strings
                for col in df.select_dtypes(include=['object']).columns:
                    df[col] = df[col].astype(str).str.strip()
                    df[col] = df[col].replace({'nan': '', 'None': '', 'NaN': ''})
                
                # Store entity model
                entity_models[sheet_name] = df
                st.success(f"âœ… Loaded entity: **{sheet_name}** ({len(df)} fields)")
                
            except Exception as e:
                st.warning(f"âš ï¸ Could not load sheet '{sheet_name}': {e}")
        
        st.success(f"âœ… **Total: {len(entity_models)} entity models loaded**")
        
        return entity_matrix, entity_models
        
    except Exception as e:
        st.error(f"âŒ Error loading Entity Model Reference: {e}")
        return None, {}

# ========================================================
# ENTITY RELATIONSHIP DIAGRAM
# ========================================================

def create_entity_relationship_diagram(entity_matrix_df, entity_models):
    """
    Create clean, scrollable ERD with organized layout and clear arrows
    """
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        entities = list(entity_models.keys()) if entity_models else []
        if not entities:
            return None
        
        # Entity info
        entity_info = {}
        for entity_name, entity_df in entity_models.items():
            entity_info[entity_name] = {'field_count': len(entity_df)}
        
        # Build relationships from Entity Matrix
        relationships = []
        
        if entity_matrix_df is not None and len(entity_matrix_df) > 0:
            matrix_columns = entity_matrix_df.columns.tolist()
            entity_columns = []
            column_to_entity_map = {}
            
            for col in matrix_columns:
                for entity_name in entities:
                    if col == clean_column_name(entity_name):
                        entity_columns.append(col)
                        column_to_entity_map[col] = entity_name
                        break
            
            for idx, row in entity_matrix_df.iterrows():
                entities_in_row = []
                relationship_keys = {}
                
                for col in entity_columns:
                    cell_value = safe_get(row, col, '')
                    if cell_value and str(cell_value).strip() and \
                       str(cell_value).strip().upper() not in ['NO MATCHING COLUMNS', 'N/A', 'NA', 'NONE']:
                        entity_name = column_to_entity_map[col]
                        entities_in_row.append(entity_name)
                        relationship_keys[entity_name] = str(cell_value).strip()
                
                if len(entities_in_row) >= 2:
                    for i, entity1 in enumerate(entities_in_row):
                        for entity2 in entities_in_row[i+1:]:
                            existing_rel = None
                            for rel in relationships:
                                if (rel['from_entity'] == entity1 and rel['to_entity'] == entity2) or \
                                   (rel['from_entity'] == entity2 and rel['to_entity'] == entity1):
                                    existing_rel = rel
                                    break
                            
                            if not existing_rel:
                                key1 = relationship_keys.get(entity1, '')
                                key2 = relationship_keys.get(entity2, '')
                                keys = list(set([k for k in [key1, key2] if k]))
                                
                                is_master = any('MASTER' in k.upper() and 'ACCOUNT' in k.upper() for k in keys)
                                is_account = any('ACCOUNT' in k.upper() and 'NUMBER' in k.upper() and 'MASTER' not in k.upper() for k in keys)
                                
                                relationships.append({
                                    'from_entity': entity1,
                                    'to_entity': entity2,
                                    'keys': keys,
                                    'is_master': is_master,
                                    'is_account': is_account
                                })
        
        # Fallback if no relationships
        if not relationships:
            for entity_name, entity_df in entity_models.items():
                source_col = None
                for col in entity_df.columns:
                    if 'source' in col.lower() and 'field' in col.lower():
                        source_col = col
                        break
                
                if source_col:
                    field_names = [str(f).upper().strip() for f in entity_df[source_col].dropna().astype(str).tolist()]
                    entity_info[entity_name]['has_account'] = any('ACCOUNT' in f and 'NUMBER' in f and 'MASTER' not in f for f in field_names)
            
            for i, entity1 in enumerate(entities):
                for entity2 in entities[i+1:]:
                    if entity_info.get(entity1, {}).get('has_account') and entity_info.get(entity2, {}).get('has_account'):
                        relationships.append({
                            'from_entity': entity1,
                            'to_entity': entity2,
                            'keys': ['ACCOUNT_NUMBER'],
                            'is_master': False,
                            'is_account': True
                        })
        
        # CLEAN GRID LAYOUT - organized in rows with proper spacing
        import math
        
        # Calculate connection count
        rel_count = {entity: 0 for entity in entities}
        for rel in relationships:
            rel_count[rel['from_entity']] += 1
            rel_count[rel['to_entity']] += 1
        
        # Sort by connection count (most connected first)
        sorted_entities = sorted(entities, key=lambda e: rel_count[e], reverse=True)
        
        # Create clean grid layout with extra spacing
        n_entities = len(sorted_entities)
        n_cols = 4  # Fixed 4 columns for consistency
        n_rows = math.ceil(n_entities / n_cols)
        
        # Much larger spacing to avoid overlap
        x_spacing = 8  # Increased from 4.5
        y_spacing = 5  # Increased from 3.5
        
        entity_positions = {}
        for idx, entity in enumerate(sorted_entities):
            row = idx // n_cols
            col = idx % n_cols
            
            x = col * x_spacing + 3
            y = (n_rows - row - 1) * y_spacing + 3  # Top to bottom
            
            entity_positions[entity] = (x, y)
        
        # Create figure with larger canvas
        fig = go.Figure()
        
        # Draw relationship arrows UNDER boxes (curved to avoid overlap)
        drawn_pairs = set()
        
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Create unique pair key
                pair = tuple(sorted([from_entity, to_entity]))
                if pair in drawn_pairs:
                    continue
                drawn_pairs.add(pair)
                
                # Determine color and width
                if rel['is_master']:
                    color = '#E74C3C'
                    width = 2.5
                elif rel['is_account']:
                    color = '#3498DB'
                    width = 2.5
                else:
                    color = '#BDC3C7'
                    width = 1.5
                
                # Draw curved arrow
                fig.add_annotation(
                    x=x2, y=y2,
                    ax=x1, ay=y1,
                    xref='x', yref='y',
                    axref='x', ayref='y',
                    showarrow=True,
                    arrowhead=2,
                    arrowsize=1.2,
                    arrowwidth=width,
                    arrowcolor=color,
                    opacity=0.7,
                    hovertext=f"{from_entity} â†” {to_entity}<br>{', '.join(rel['keys'][:2])}",
                )
        
        # Draw entity boxes (larger and cleaner)
        for entity_name, (x_center, y_center) in entity_positions.items():
            field_count = entity_info[entity_name]['field_count']
            connections = rel_count[entity_name]
            
            # Color coding
            if connections >= 6:
                color = '#8E44AD'  # Purple
            elif connections >= 4:
                color = '#3498DB'  # Blue
            elif connections >= 2:
                color = '#27AE60'  # Green
            elif connections >= 1:
                color = '#F39C12'  # Orange
            else:
                color = '#95A5A6'  # Gray
            
            # Larger boxes with rounded corners effect
            w, h = 3.0, 1.5
            x0, x1 = x_center - w/2, x_center + w/2
            y0, y1 = y_center - h/2, y_center + h/2
            
            # Shadow effect (slightly offset)
            fig.add_shape(type="rect", x0=x0+0.1, y0=y0-0.1, x1=x1+0.1, y1=y1-0.1,
                         fillcolor='rgba(0,0,0,0.1)', line_width=0, layer='below')
            
            # Main box
            fig.add_shape(type="rect", x0=x0, y0=y0, x1=x1, y1=y1,
                         line=dict(color="#2C3E50", width=2),
                         fillcolor="#FFFFFF", layer='below')
            
            # Header
            fig.add_shape(type="rect", x0=x0, y0=y_center+0.1, x1=x1, y1=y1,
                         fillcolor=color, line_width=0, layer='below')
            
            # Divider
            fig.add_shape(type="line", x0=x0, y0=y_center+0.1, x1=x1, y1=y_center+0.1,
                         line=dict(color="#2C3E50", width=2))
            
            # Entity name (larger, bold)
            fig.add_trace(go.Scatter(
                x=[x_center], y=[y_center + h/3],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=14, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Info text
            info_text = f"{field_count} fields"
            if connections > 0:
                info_text += f" â€¢ {connections} links"
            
            fig.add_trace(go.Scatter(
                x=[x_center], y=[y_center - h/3],
                mode='text',
                text=[info_text],
                textfont=dict(size=11, color='#34495E'),
                hoverinfo='text',
                hovertext=f"<b>{entity_name}</b><br>Fields: {field_count}<br>Connections: {connections}",
                showlegend=False
            ))
        
        # Calculate canvas size
        canvas_width = n_cols * x_spacing + 6
        canvas_height = n_rows * y_spacing + 6
        
        # Ultra-clean layout with scroll/zoom
        fig.update_layout(
            title=dict(
                text="<b>Entity Relationship Diagram</b>",
                x=0.5, xanchor='center',
                font=dict(size=24, color='#2C3E50', family='Arial Black')
            ),
            xaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False, 
                range=[-1, canvas_width]
            ),
            yaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False, 
                range=[-1, canvas_height],
                scaleanchor="x",
                scaleratio=1
            ),
            height=800,  # Larger height
            plot_bgcolor='#F8F9FA',
            paper_bgcolor='#FFFFFF',
            hovermode='closest',
            margin=dict(l=10, r=10, t=80, b=10),
            showlegend=False,
            # Enable drag and zoom
            dragmode='pan',
        )
        
        # Add zoom/pan configuration
        fig.update_xaxes(fixedrange=False)
        fig.update_yaxes(fixedrange=False)
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        entities = list(entity_models.keys()) if entity_models else []
        if not entities:
            return None
        
        # Entity info
        entity_info = {}
        for entity_name, entity_df in entity_models.items():
            entity_info[entity_name] = {'field_count': len(entity_df)}
        
        # Build relationships from Entity Matrix
        relationships = []
        
        if entity_matrix_df is not None and len(entity_matrix_df) > 0:
            matrix_columns = entity_matrix_df.columns.tolist()
            
            # Match columns to entities
            entity_columns = []
            column_to_entity_map = {}
            
            for col in matrix_columns:
                for entity_name in entities:
                    if col == clean_column_name(entity_name):
                        entity_columns.append(col)
                        column_to_entity_map[col] = entity_name
                        break
            
            # Build relationships
            for idx, row in entity_matrix_df.iterrows():
                entities_in_row = []
                relationship_keys = {}
                
                for col in entity_columns:
                    cell_value = safe_get(row, col, '')
                    if cell_value and str(cell_value).strip() and \
                       str(cell_value).strip().upper() not in ['NO MATCHING COLUMNS', 'N/A', 'NA', 'NONE']:
                        entity_name = column_to_entity_map[col]
                        entities_in_row.append(entity_name)
                        relationship_keys[entity_name] = str(cell_value).strip()
                
                if len(entities_in_row) >= 2:
                    for i, entity1 in enumerate(entities_in_row):
                        for entity2 in entities_in_row[i+1:]:
                            existing_rel = None
                            for rel in relationships:
                                if (rel['from_entity'] == entity1 and rel['to_entity'] == entity2) or \
                                   (rel['from_entity'] == entity2 and rel['to_entity'] == entity1):
                                    existing_rel = rel
                                    break
                            
                            if not existing_rel:
                                key1 = relationship_keys.get(entity1, '')
                                key2 = relationship_keys.get(entity2, '')
                                keys = list(set([k for k in [key1, key2] if k]))
                                
                                is_master = any('MASTER' in k.upper() and 'ACCOUNT' in k.upper() for k in keys)
                                is_account = any('ACCOUNT' in k.upper() and 'NUMBER' in k.upper() and 'MASTER' not in k.upper() for k in keys)
                                
                                relationships.append({
                                    'from_entity': entity1,
                                    'to_entity': entity2,
                                    'keys': keys,
                                    'is_master': is_master,
                                    'is_account': is_account
                                })
        
        # If no relationships, use field-based fallback
        if not relationships:
            for entity_name, entity_df in entity_models.items():
                source_col = None
                for col in entity_df.columns:
                    if 'source' in col.lower() and 'field' in col.lower():
                        source_col = col
                        break
                
                if source_col:
                    field_names = [str(f).upper().strip() for f in entity_df[source_col].dropna().astype(str).tolist()]
                    entity_info[entity_name]['has_account'] = any('ACCOUNT' in f and 'NUMBER' in f and 'MASTER' not in f for f in field_names)
                    entity_info[entity_name]['has_master'] = any('MASTER' in f and 'ACCOUNT' in f for f in field_names)
            
            for i, entity1 in enumerate(entities):
                for entity2 in entities[i+1:]:
                    if entity_info.get(entity1, {}).get('has_account') and entity_info.get(entity2, {}).get('has_account'):
                        relationships.append({
                            'from_entity': entity1,
                            'to_entity': entity2,
                            'keys': ['ACCOUNT_NUMBER'],
                            'is_master': False,
                            'is_account': True
                        })
        
        # HIERARCHICAL LAYOUT - organize by connection count
        rel_count = {entity: 0 for entity in entities}
        for rel in relationships:
            rel_count[rel['from_entity']] += 1
            rel_count[rel['to_entity']] += 1
        
        # Sort entities by connection count (most connected at top)
        sorted_entities = sorted(entities, key=lambda e: rel_count[e], reverse=True)
        
        # Create 3-level hierarchy
        import math
        n_entities = len(sorted_entities)
        n_cols = min(5, max(3, math.ceil(math.sqrt(n_entities))))
        
        # Position entities in rows (top to bottom)
        entity_positions = {}
        entities_per_row = n_cols
        current_row = 0
        current_col = 0
        
        for entity in sorted_entities:
            x = current_col * 4.5 + 2
            y = 8 - (current_row * 3.5)  # Top to bottom
            entity_positions[entity] = (x, y)
            
            current_col += 1
            if current_col >= entities_per_row:
                current_col = 0
                current_row += 1
        
        fig = go.Figure()
        
        # Draw relationship ARROWS (not just lines)
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Determine color
                if rel['is_master']:
                    color = '#E74C3C'
                    label = 'Masterâ†’Child'
                elif rel['is_account']:
                    color = '#3498DB'
                    label = 'Account Link'
                else:
                    color = '#95A5A6'
                    label = 'Related'
                
                # Draw arrow line
                fig.add_annotation(
                    x=x2, y=y2,
                    ax=x1, ay=y1,
                    xref='x', yref='y',
                    axref='x', ayref='y',
                    showarrow=True,
                    arrowhead=2,
                    arrowsize=1.5,
                    arrowwidth=2,
                    arrowcolor=color,
                    hovertext=f"{label}<br>{from_entity} â†’ {to_entity}<br>{', '.join(rel['keys'][:2])}",
                )
        
        # Draw entity boxes (larger, cleaner)
        for entity_name, (x_center, y_center) in entity_positions.items():
            field_count = entity_info[entity_name]['field_count']
            connections = rel_count[entity_name]
            
            # Color by connection count
            if connections >= 5:
                color = '#8E44AD'  # Purple - hub
            elif connections >= 3:
                color = '#3498DB'  # Blue - well connected
            elif connections >= 1:
                color = '#27AE60'  # Green - connected
            else:
                color = '#95A5A6'  # Gray - isolated
            
            # Larger boxes
            w, h = 2.5, 1.2
            x0, x1 = x_center - w/2, x_center + w/2
            y0, y1 = y_center - h/2, y_center + h/2
            
            # Box border
            fig.add_shape(type="rect", x0=x0, y0=y0, x1=x1, y1=y1,
                         line=dict(color="#34495E", width=2),
                         fillcolor="#ECF0F1", layer='below')
            
            # Header section
            fig.add_shape(type="rect", x0=x0, y0=y_center, x1=x1, y1=y1,
                         fillcolor=color, line_width=0, layer='below')
            
            # Divider
            fig.add_shape(type="line", x0=x0, y0=y_center, x1=x1, y1=y_center,
                         line=dict(color="#34495E", width=2))
            
            # Entity name (larger text)
            fig.add_trace(go.Scatter(
                x=[x_center], y=[y_center + h/4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=13, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Field count
            fig.add_trace(go.Scatter(
                x=[x_center], y=[y_center - h/4],
                mode='text',
                text=[f"{field_count} fields | {connections} links"],
                textfont=dict(size=10, color='#2C3E50'),
                hoverinfo='text',
                hovertext=f"<b>{entity_name}</b><br>Fields: {field_count}<br>Connections: {connections}",
                showlegend=False
            ))
        
        # Clean layout
        fig.update_layout(
            title=dict(
                text="<b>Entity Relationship Diagram</b>",
                x=0.5, xanchor='center',
                font=dict(size=20, color='#2C3E50', family='Arial Black')
            ),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[0, n_cols*4.5+2]),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-2, 10]),
            height=700,
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=20, r=20, t=80, b=20),
            showlegend=False
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Entity info (field counts)
        entity_info = {}
        for entity_name, entity_df in entity_models.items():
            entity_info[entity_name] = {
                'field_count': len(entity_df)
            }
        
        # Build relationships from Entity Matrix
        relationships = []
        
        if entity_matrix_df is not None and len(entity_matrix_df) > 0:
            st.info(f"ðŸ” Analyzing Entity Matrix: {len(entity_matrix_df)} rows, {len(entity_matrix_df.columns)} columns")
            
            # Get column names from Entity Matrix (already cleaned by loader)
            matrix_columns = entity_matrix_df.columns.tolist()
            
            # Match matrix columns with entity sheet names
            # Both have been cleaned by clean_column_name(), so direct comparison should work
            entity_columns = []
            column_to_entity_map = {}
            
            for col in matrix_columns:
                # Check if this cleaned column matches any cleaned entity name
                for entity_name in entities:
                    # Clean both for comparison
                    if col == clean_column_name(entity_name):
                        entity_columns.append(col)
                        column_to_entity_map[col] = entity_name
                        break
            
            # DEBUG: Show what we found
            st.success(f"âœ… Matched {len(entity_columns)} entity columns from {len(matrix_columns)} total columns")
            with st.expander("ðŸ” DEBUG: Column Matching", expanded=True):
                st.write("**Entity Matrix columns:**", matrix_columns[:15])
                st.write("**Entity sheet names:**", entities[:15])
                st.write("**Matched columns:**", entity_columns)
                st.write("**Column to Entity mapping:**", column_to_entity_map)
                
                # Show sample data
                if len(entity_matrix_df) > 0:
                    st.write("**Sample row from Entity Matrix:**")
                    st.dataframe(entity_matrix_df.head(3))
            
            if not entity_columns:
                st.error("âŒ No entity columns matched!")
                st.write("Matrix column names need to match entity sheet names (after cleaning)")
                st.write("**Tip:** Rename Entity Matrix columns to match entity sheet names exactly")
                return None
            
            # Build relationships from Entity Matrix
            row_relationships = 0
            for idx, row in entity_matrix_df.iterrows():
                # Find which entities have values in this row
                entities_in_row = []
                relationship_keys = {}
                
                for col in entity_columns:
                    cell_value = safe_get(row, col, '')
                    # Check if cell has a value (not empty, not "No matching Columns")
                    if cell_value and \
                       str(cell_value).strip() and \
                       str(cell_value).strip().upper() not in ['NO MATCHING COLUMNS', 'N/A', 'NA', 'NONE']:
                        entity_name = column_to_entity_map[col]
                        entities_in_row.append(entity_name)
                        relationship_keys[entity_name] = str(cell_value).strip()
                
                # Connect all entities that appear in this row (minimum 2 entities)
                if len(entities_in_row) >= 2:
                    row_relationships += 1
                    
                    # DEBUG: Show first few rows
                    if row_relationships <= 5:
                        with st.expander(f"Row {idx}: Connecting {len(entities_in_row)} entities", expanded=False):
                            st.write(f"**Entities:** {entities_in_row}")
                            st.write(f"**Keys:** {relationship_keys}")
                    
                    for i, entity1 in enumerate(entities_in_row):
                        for entity2 in entities_in_row[i+1:]:
                            # Check if relationship already exists
                            existing_rel = None
                            for rel in relationships:
                                if (rel['from_entity'] == entity1 and rel['to_entity'] == entity2) or \
                                   (rel['from_entity'] == entity2 and rel['to_entity'] == entity1):
                                    existing_rel = rel
                                    break
                            
                            if existing_rel:
                                # Add to existing relationship's keys
                                key1 = relationship_keys.get(entity1, '')
                                key2 = relationship_keys.get(entity2, '')
                                if key1 and key1 not in existing_rel['keys']:
                                    existing_rel['keys'].append(key1)
                                if key2 and key2 not in existing_rel['keys']:
                                    existing_rel['keys'].append(key2)
                            else:
                                # Create new relationship
                                key1 = relationship_keys.get(entity1, '')
                                key2 = relationship_keys.get(entity2, '')
                                keys = list(set([k for k in [key1, key2] if k]))
                                
                                # Determine relationship type based on keys
                                is_master_account = any('MASTER' in k.upper() and 'ACCOUNT' in k.upper() for k in keys)
                                is_account = any('ACCOUNT' in k.upper() and 'NUMBER' in k.upper() and 'MASTER' not in k.upper() for k in keys)
                                
                                if is_master_account:
                                    rel_type = 'MASTER_ACCOUNT_NUMBER'
                                    color = '#E74C3C'  # Red
                                    width = 3
                                elif is_account:
                                    rel_type = 'ACCOUNT_NUMBER'
                                    color = '#3498DB'  # Blue
                                    width = 3
                                else:
                                    rel_type = 'Related'
                                    color = '#95A5A6'  # Gray
                                    width = 2
                                
                                relationships.append({
                                    'from_entity': entity1,
                                    'to_entity': entity2,
                                    'type': rel_type,
                                    'keys': keys,
                                    'color': color,
                                    'width': width
                                })
            
            # Show final relationship count
            st.success(f"âœ… Built {len(relationships)} relationships from {row_relationships} Entity Matrix rows")
            with st.expander("ðŸ” All Relationships Found", expanded=False):
                for rel in relationships:
                    st.write(f"**{rel['from_entity']} â†” {rel['to_entity']}** ({rel['type']})")
        
        # If no relationships from matrix, fall back to field-based detection
        if not relationships:
            st.warning("âš ï¸ No relationships found in Entity Matrix. Using field-based fallback...")
            
            # Field-based detection code here
            for entity_name, entity_df in entity_models.items():
                source_col = None
                for col in entity_df.columns:
                    if 'source' in col.lower() and 'field' in col.lower():
                        source_col = col
                        break
                
                if source_col:
                    field_names = [str(f).upper().strip() for f in entity_df[source_col].dropna().astype(str).tolist()]
                    entity_info[entity_name]['has_account_number'] = any('ACCOUNT' in f and 'NUMBER' in f and 'MASTER' not in f for f in field_names)
                    entity_info[entity_name]['has_master_account'] = any('MASTER' in f and 'ACCOUNT' in f for f in field_names)
            
            for i, entity1 in enumerate(entities):
                for entity2 in entities[i+1:]:
                    info1 = entity_info.get(entity1, {})
                    info2 = entity_info.get(entity2, {})
                    
                    if info1.get('has_account_number') and info2.get('has_account_number'):
                        relationships.append({
                            'from_entity': entity1,
                            'to_entity': entity2,
                            'type': 'ACCOUNT_NUMBER',
                            'keys': ['ACCOUNT_NUMBER'],
                            'color': '#3498DB',
                            'width': 3
                        })
                    
                    if info1.get('has_master_account') and info2.get('has_master_account'):
                        already_related = any(
                            (r['from_entity'] == entity1 and r['to_entity'] == entity2) or
                            (r['from_entity'] == entity2 and r['to_entity'] == entity1)
                            for r in relationships
                        )
                        if not already_related:
                            relationships.append({
                                'from_entity': entity1,
                                'to_entity': entity2,
                                'type': 'MASTER_ACCOUNT_NUMBER',
                                'keys': ['MASTER_ACCOUNT_NUMBER'],
                                'color': '#E74C3C',
                                'width': 3
                            })
            
            st.info(f"Built {len(relationships)} relationships using field-based detection")
        
        # Rest of the visualization code...
        import math
        n_entities = len(entities)
        entity_positions = {}
        radius = max(4, n_entities * 0.6)
        
        for i, entity_name in enumerate(entities):
            angle = 2 * math.pi * i / n_entities
            x = radius * math.cos(angle)
            y = radius * math.sin(angle)
            entity_positions[entity_name] = (x, y)
        
        fig = go.Figure()
        
        # Draw relationship lines
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                hover_text = f"<b>{rel['type']}</b><br>"
                hover_text += f"{from_entity} â†” {to_entity}<br>"
                if rel['keys']:
                    hover_text += f"Keys: {', '.join(rel['keys'][:3])}"
                
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color=rel['color'], width=rel['width']),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
        
        # Draw entity rectangles
        for entity_name, (x_center, y_center) in entity_positions.items():
            info = entity_info.get(entity_name, {})
            field_count = info.get('field_count', 0)
            
            rel_count = sum(1 for r in relationships if r['from_entity'] == entity_name or r['to_entity'] == entity_name)
            
            if rel_count > 5:
                header_color = '#8E44AD'
                entity_icon = 'ðŸ”—'
            elif rel_count > 2:
                header_color = '#3498DB'
                entity_icon = 'ðŸ”µ'
            elif rel_count > 0:
                header_color = '#27AE60'
                entity_icon = 'ðŸŸ¢'
            else:
                header_color = '#95A5A6'
                entity_icon = 'âšª'
            
            rect_width = 2.0
            rect_height = 1.0
            
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor=header_color,
                layer='below'
            )
            
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=11, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            field_info = f"{entity_icon} {field_count} fields"
            
            hover_info = f"<b>{entity_name}</b><br>"
            hover_info += f"Fields: {field_count}<br>"
            hover_info += f"Relationships: {rel_count}"
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[field_info],
                textfont=dict(size=9, color='#2C3E50'),
                hoverinfo='text',
                hovertext=hover_info,
                showlegend=False
            ))
        
        # Legend
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#3498DB', width=3),
            name='ACCOUNT_NUMBER'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#E74C3C', width=3),
            name='MASTER_ACCOUNT_NUMBER'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#95A5A6', width=2),
            name='Other'
        ))
        
        fig.update_layout(
            title=dict(
                text="ðŸ“Š Entity Relationship Diagram<br><sub>From Entity Matrix sheet</sub>",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-radius-2, radius+2]),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-radius-2, radius+2]),
            height=700,
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=120, b=80),
            showlegend=True,
            legend=dict(x=0.5, y=-0.1, xanchor='center', yanchor='top', orientation='h', bgcolor='rgba(255,255,255,0.9)', bordercolor='#2C3E50', borderwidth=1)
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    """
    Create ERD using Entity Matrix sheet for relationship mapping
    Entity Matrix shows which entities are related through specific columns
    """
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Entity info (field counts)
        entity_info = {}
        for entity_name, entity_df in entity_models.items():
            entity_info[entity_name] = {
                'field_count': len(entity_df)
            }
        
        # Build relationships from Entity Matrix
        relationships = []
        
        if entity_matrix_df is not None and len(entity_matrix_df) > 0:
            # Get column names from Entity Matrix (excluding first few metadata columns)
            matrix_columns = entity_matrix_df.columns.tolist()
            
            # Identify entity columns (skip metadata columns like 'Account', 'Account User', 'Master Account')
            # Entity columns are those that contain "ACCOUNT_NUMBER" or similar values
            entity_columns = []
            
            for col in matrix_columns:
                col_str = str(col).strip()
                # Skip empty or unnamed columns
                if col_str and col_str not in ['Account', 'Account User', 'Account Entity', 'Master Account', 'Unnamed']:
                    entity_columns.append(col_str)
            
            # Build relationships from Entity Matrix
            # Each row represents a connection point
            # If two entity columns have values in the same row, they are related
            
            for _, row in entity_matrix_df.iterrows():
                # Find which entities have values in this row
                entities_in_row = []
                relationship_keys = {}
                
                for col in entity_columns:
                    cell_value = safe_get(row, col, '')
                    if cell_value and str(cell_value).strip() and str(cell_value).strip().upper() != 'NO MATCHING COLUMNS':
                        entities_in_row.append(col)
                        relationship_keys[col] = str(cell_value).strip()
                
                # Connect all entities that appear in this row
                for i, entity1 in enumerate(entities_in_row):
                    for entity2 in entities_in_row[i+1:]:
                        # Check if relationship already exists
                        existing_rel = None
                        for rel in relationships:
                            if (rel['from_entity'] == entity1 and rel['to_entity'] == entity2) or \
                               (rel['from_entity'] == entity2 and rel['to_entity'] == entity1):
                                existing_rel = rel
                                break
                        
                        if existing_rel:
                            # Add to existing relationship's keys
                            key1 = relationship_keys.get(entity1, '')
                            key2 = relationship_keys.get(entity2, '')
                            if key1 and key1 not in existing_rel['keys']:
                                existing_rel['keys'].append(key1)
                            if key2 and key2 not in existing_rel['keys']:
                                existing_rel['keys'].append(key2)
                        else:
                            # Create new relationship
                            key1 = relationship_keys.get(entity1, '')
                            key2 = relationship_keys.get(entity2, '')
                            keys = list(set([k for k in [key1, key2] if k]))
                            
                            # Determine relationship type based on keys
                            is_master_account = any('MASTER' in k.upper() and 'ACCOUNT' in k.upper() for k in keys)
                            is_account = any('ACCOUNT' in k.upper() and 'NUMBER' in k.upper() and 'MASTER' not in k.upper() for k in keys)
                            
                            if is_master_account:
                                rel_type = 'MASTER_ACCOUNT_NUMBER'
                                color = '#E74C3C'  # Red
                                width = 3
                            elif is_account:
                                rel_type = 'ACCOUNT_NUMBER'
                                color = '#3498DB'  # Blue
                                width = 3
                            else:
                                rel_type = 'Related'
                                color = '#95A5A6'  # Gray
                                width = 2
                            
                            relationships.append({
                                'from_entity': entity1,
                                'to_entity': entity2,
                                'type': rel_type,
                                'keys': keys,
                                'color': color,
                                'width': width
                            })
        
        # If no relationships from matrix, fall back to field-based detection
        if not relationships:
            st.info("No Entity Matrix found or no relationships detected. Using field-based detection.")
            
            # Analyze fields for each entity
            for entity_name, entity_df in entity_models.items():
                source_col = None
                for col in entity_df.columns:
                    if 'source' in col.lower() and 'field' in col.lower():
                        source_col = col
                        break
                
                if source_col:
                    field_names = [str(f).upper().strip() for f in entity_df[source_col].dropna().astype(str).tolist()]
                    entity_info[entity_name]['has_account_number'] = any('ACCOUNT' in f and 'NUMBER' in f and 'MASTER' not in f for f in field_names)
                    entity_info[entity_name]['has_master_account'] = any('MASTER' in f and 'ACCOUNT' in f for f in field_names)
            
            # Build relationships from shared fields
            for i, entity1 in enumerate(entities):
                for entity2 in entities[i+1:]:
                    info1 = entity_info.get(entity1, {})
                    info2 = entity_info.get(entity2, {})
                    
                    if info1.get('has_account_number') and info2.get('has_account_number'):
                        relationships.append({
                            'from_entity': entity1,
                            'to_entity': entity2,
                            'type': 'ACCOUNT_NUMBER',
                            'keys': ['ACCOUNT_NUMBER'],
                            'color': '#3498DB',
                            'width': 3
                        })
                    
                    if info1.get('has_master_account') and info2.get('has_master_account'):
                        already_related = any(
                            (r['from_entity'] == entity1 and r['to_entity'] == entity2) or
                            (r['from_entity'] == entity2 and r['to_entity'] == entity1)
                            for r in relationships
                        )
                        if not already_related:
                            relationships.append({
                                'from_entity': entity1,
                                'to_entity': entity2,
                                'type': 'MASTER_ACCOUNT_NUMBER',
                                'keys': ['MASTER_ACCOUNT_NUMBER'],
                                'color': '#E74C3C',
                                'width': 3
                            })
        
        # Layout entities in a circular pattern
        import math
        n_entities = len(entities)
        entity_positions = {}
        radius = max(4, n_entities * 0.6)
        
        for i, entity_name in enumerate(entities):
            angle = 2 * math.pi * i / n_entities
            x = radius * math.cos(angle)
            y = radius * math.sin(angle)
            entity_positions[entity_name] = (x, y)
        
        fig = go.Figure()
        
        # Draw relationship lines
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Hover text
                hover_text = f"<b>{rel['type']}</b><br>"
                hover_text += f"{from_entity} â†” {to_entity}<br>"
                if rel['keys']:
                    hover_text += f"Keys: {', '.join(rel['keys'][:3])}"
                
                # Draw line
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color=rel['color'], width=rel['width']),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
        
        # Draw entity rectangles
        for entity_name, (x_center, y_center) in entity_positions.items():
            info = entity_info.get(entity_name, {})
            field_count = info.get('field_count', 0)
            
            # Count relationships for this entity
            rel_count = sum(1 for r in relationships if r['from_entity'] == entity_name or r['to_entity'] == entity_name)
            
            # Color based on relationship count
            if rel_count > 5:
                header_color = '#8E44AD'  # Purple - highly connected
                entity_icon = 'ðŸ”—'
            elif rel_count > 2:
                header_color = '#3498DB'  # Blue - well connected
                entity_icon = 'ðŸ”µ'
            elif rel_count > 0:
                header_color = '#27AE60'  # Green - connected
                entity_icon = 'ðŸŸ¢'
            else:
                header_color = '#95A5A6'  # Gray - isolated
                entity_icon = 'âšª'
            
            # Rectangle dimensions
            rect_width = 2.0
            rect_height = 1.0
            
            # Coordinates
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            # Border
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            # Header
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor=header_color,
                layer='below'
            )
            
            # Divider
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            # Entity name
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=11, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Field count
            field_info = f"{entity_icon} {field_count} fields"
            
            hover_info = f"<b>{entity_name}</b><br>"
            hover_info += f"Fields: {field_count}<br>"
            hover_info += f"Relationships: {rel_count}"
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[field_info],
                textfont=dict(size=9, color='#2C3E50'),
                hoverinfo='text',
                hovertext=hover_info,
                showlegend=False
            ))
        
        # Legend
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#3498DB', width=3),
            name='ACCOUNT_NUMBER'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#E74C3C', width=3),
            name='MASTER_ACCOUNT_NUMBER'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#95A5A6', width=2),
            name='Other Relationship'
        ))
        
        # Layout
        fig.update_layout(
            title=dict(
                text="ðŸ“Š Entity Relationship Diagram (from Entity Matrix)<br><sub>Relationships mapped from Entity Matrix sheet</sub>",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-radius-2, radius+2]
            ),
            yaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-radius-2, radius+2]
            ),
            height=700,
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=120, b=80),
            showlegend=True,
            legend=dict(
                x=0.5, y=-0.1, xanchor='center', yanchor='top',
                orientation='h', bgcolor='rgba(255,255,255,0.9)',
                bordercolor='#2C3E50', borderwidth=1
            )
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Analyze each entity for key fields
        entity_info = {}
        
        for entity_name, entity_df in entity_models.items():
            # Find source field column
            source_col = None
            for col in entity_df.columns:
                if 'source' in col.lower() and 'field' in col.lower():
                    source_col = col
                    break
            
            # Get all field names (uppercase for comparison)
            field_names = []
            if source_col:
                field_names = [str(f).upper().strip() for f in entity_df[source_col].dropna().astype(str).tolist()]
            
            # Check for ACCOUNT_NUMBER (not MASTER_ACCOUNT_NUMBER)
            has_account_number = any(
                'ACCOUNT' in f and 'NUMBER' in f and 'MASTER' not in f 
                for f in field_names
            )
            
            # Check for MASTER_ACCOUNT_NUMBER
            has_master_account_number = any(
                'MASTER' in f and 'ACCOUNT' in f and 'NUMBER' in f 
                for f in field_names
            )
            
            entity_info[entity_name] = {
                'field_count': len(entity_df),
                'has_account_number': has_account_number,
                'has_master_account_number': has_master_account_number
            }
        
        # Build relationships based on shared fields
        relationships = []
        
        # Group entities by the keys they have
        entities_with_account_number = [e for e, info in entity_info.items() if info['has_account_number']]
        entities_with_master_account = [e for e, info in entity_info.items() if info['has_master_account_number']]
        
        # Connect all entities that have ACCOUNT_NUMBER
        for i, entity1 in enumerate(entities_with_account_number):
            for entity2 in entities_with_account_number[i+1:]:
                relationships.append({
                    'from_entity': entity1,
                    'to_entity': entity2,
                    'key': 'ACCOUNT_NUMBER',
                    'color': '#3498DB',  # Blue
                    'width': 3,
                    'dash': 'solid'
                })
        
        # Connect all entities that have MASTER_ACCOUNT_NUMBER
        for i, entity1 in enumerate(entities_with_master_account):
            for entity2 in entities_with_master_account[i+1:]:
                # Check if not already connected
                already_connected = any(
                    (r['from_entity'] == entity1 and r['to_entity'] == entity2) or
                    (r['from_entity'] == entity2 and r['to_entity'] == entity1)
                    for r in relationships
                )
                
                if not already_connected:
                    relationships.append({
                        'from_entity': entity1,
                        'to_entity': entity2,
                        'key': 'MASTER_ACCOUNT_NUMBER',
                        'color': '#E74C3C',  # Red
                        'width': 3,
                        'dash': 'solid'
                    })
        
        # Layout entities in a circular or grid pattern
        import math
        n_entities = len(entities)
        
        # Use circular layout for better relationship visualization
        entity_positions = {}
        radius = max(4, n_entities * 0.6)
        
        for i, entity_name in enumerate(entities):
            angle = 2 * math.pi * i / n_entities
            x = radius * math.cos(angle)
            y = radius * math.sin(angle)
            entity_positions[entity_name] = (x, y)
        
        fig = go.Figure()
        
        # Draw relationship lines
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Hover text
                hover_text = f"<b>Connected via {rel['key']}</b><br>"
                hover_text += f"{from_entity} â†” {to_entity}"
                
                # Draw line
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color=rel['color'], width=rel['width'], dash=rel['dash']),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
        
        # Draw entity rectangles
        for entity_name, (x_center, y_center) in entity_positions.items():
            info = entity_info[entity_name]
            field_count = info['field_count']
            
            # Determine color based on which keys this entity has
            if info['has_account_number'] and info['has_master_account_number']:
                header_color = '#8E44AD'  # Purple (has both)
                entity_icon = 'ðŸ”—'
            elif info['has_master_account_number']:
                header_color = '#E74C3C'  # Red (master account number)
                entity_icon = 'ðŸ”´'
            elif info['has_account_number']:
                header_color = '#3498DB'  # Blue (account number)
                entity_icon = 'ðŸ”µ'
            else:
                header_color = '#95A5A6'  # Gray (no key fields)
                entity_icon = 'âšª'
            
            # Rectangle dimensions
            rect_width = 2.0
            rect_height = 1.0
            
            # Coordinates
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            # Border
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            # Header
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor=header_color,
                layer='below'
            )
            
            # Divider
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            # Entity name
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=11, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Field count with icon
            field_info = f"{entity_icon} {field_count} fields"
            
            # Build hover info
            hover_info = f"<b>{entity_name}</b><br>"
            hover_info += f"Fields: {field_count}<br>"
            hover_info += "<br><b>Has:</b><br>"
            if info['has_account_number']:
                hover_info += "âœ“ ACCOUNT_NUMBER<br>"
            if info['has_master_account_number']:
                hover_info += "âœ“ MASTER_ACCOUNT_NUMBER<br>"
            if not info['has_account_number'] and not info['has_master_account_number']:
                hover_info += "(No key fields)<br>"
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[field_info],
                textfont=dict(size=9, color='#2C3E50'),
                hoverinfo='text',
                hovertext=hover_info,
                showlegend=False
            ))
        
        # Add legend
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#3498DB', width=3),
            name='Connected via ACCOUNT_NUMBER'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#E74C3C', width=3),
            name='Connected via MASTER_ACCOUNT_NUMBER'
        ))
        
        # Layout
        fig.update_layout(
            title=dict(
                text="ðŸ“Š Entity Relationship Diagram<br><sub>ðŸ”µ ACCOUNT_NUMBER | ðŸ”´ MASTER_ACCOUNT_NUMBER | ðŸ”— Both</sub>",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-radius-2, radius+2]
            ),
            yaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-radius-2, radius+2]
            ),
            height=700,
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=120, b=80),
            showlegend=True,
            legend=dict(
                x=0.5, y=-0.1, xanchor='center', yanchor='top',
                orientation='h', bgcolor='rgba(255,255,255,0.9)',
                bordercolor='#2C3E50', borderwidth=1
            )
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Analyze each entity
        entity_info = {}
        master_account_entity = None
        
        for entity_name, entity_df in entity_models.items():
            # Find source field column
            source_col = None
            for col in entity_df.columns:
                if 'source' in col.lower() and 'field' in col.lower():
                    source_col = col
                    break
            
            # Get all field names (uppercase for comparison)
            field_names = []
            if source_col:
                field_names = [str(f).upper().strip() for f in entity_df[source_col].dropna().astype(str).tolist()]
            
            # Check for key fields
            has_account_number = any('ACCOUNT' in f and 'NUMBER' in f and 'MASTER' not in f for f in field_names)
            has_master_account_number = any('MASTER' in f and 'ACCOUNT' in f and 'NUMBER' in f for f in field_names)
            
            # Identify if this is the Master Account entity
            is_master_account = 'MASTER' in entity_name.upper() and 'ACCOUNT' in entity_name.upper()
            
            if is_master_account:
                master_account_entity = entity_name
            
            entity_info[entity_name] = {
                'field_count': len(entity_df),
                'field_names': field_names,
                'has_account_number': has_account_number,
                'has_master_account_number': has_master_account_number,
                'is_master_account': is_master_account
            }
        
        # Build relationships
        relationships = []
        
        # Master Account â†’ Child relationships
        # Any entity with MASTER_ACCOUNT_NUMBER is a child of Master Account
        if master_account_entity:
            for entity_name, info in entity_info.items():
                if entity_name != master_account_entity and info['has_master_account_number']:
                    relationships.append({
                        'from_entity': master_account_entity,
                        'to_entity': entity_name,
                        'type': 'Parent-Child',
                        'key': 'MASTER_ACCOUNT_NUMBER',
                        'color': '#E74C3C',
                        'width': 4,
                        'dash': 'solid'
                    })
        
        # Find other relationships (entities with shared key fields)
        for i, entity1 in enumerate(entities):
            for entity2 in entities[i+1:]:
                # Skip if already parent-child
                already_related = any(
                    (r['from_entity'] == entity1 and r['to_entity'] == entity2) or
                    (r['from_entity'] == entity2 and r['to_entity'] == entity1)
                    for r in relationships
                )
                
                if not already_related:
                    fields1 = set(entity_info[entity1]['field_names'])
                    fields2 = set(entity_info[entity2]['field_names'])
                    common = fields1 & fields2
                    
                    # Look for key fields
                    key_fields = [f for f in common if any(kw in f for kw in ['ACCOUNT_NUMBER', 'CUSTOMER_ID', 'ID', 'NUMBER', 'KEY'])]
                    
                    if key_fields:
                        relationships.append({
                            'from_entity': entity1,
                            'to_entity': entity2,
                            'type': 'Shared Key',
                            'key': key_fields[0],
                            'color': '#95A5A6',
                            'width': 2,
                            'dash': 'dash'
                        })
        
        # Layout entities in a hierarchical way
        import math
        
        # Position Master Account at top center
        entity_positions = {}
        
        if master_account_entity:
            # Master at top
            entity_positions[master_account_entity] = (5, 6)
            
            # Children below in a row
            children = [e for e in entities if e != master_account_entity and entity_info[e]['has_master_account_number']]
            other_entities = [e for e in entities if e != master_account_entity and not entity_info[e]['has_master_account_number']]
            
            # Position children
            n_children = len(children)
            if n_children > 0:
                spacing = 3
                start_x = 5 - (n_children - 1) * spacing / 2
                for i, child in enumerate(children):
                    entity_positions[child] = (start_x + i * spacing, 3)
            
            # Position other entities
            n_others = len(other_entities)
            if n_others > 0:
                spacing = 2.5
                start_x = 5 - (n_others - 1) * spacing / 2
                for i, other in enumerate(other_entities):
                    entity_positions[other] = (start_x + i * spacing, 0)
        else:
            # No master account, use grid layout
            n_entities = len(entities)
            n_cols = min(4, math.ceil(math.sqrt(n_entities)))
            n_rows = math.ceil(n_entities / n_cols)
            
            entity_idx = 0
            for row in range(n_rows):
                for col in range(n_cols):
                    if entity_idx < n_entities:
                        entity_name = entities[entity_idx]
                        x = col * 3.5
                        y = (n_rows - 1 - row) * 3
                        entity_positions[entity_name] = (x, y)
                        entity_idx += 1
        
        fig = go.Figure()
        
        # Draw relationship lines
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Hover text
                hover_text = f"<b>{rel['type']}</b><br>"
                hover_text += f"{from_entity} â†’ {to_entity}<br>"
                hover_text += f"via: {rel['key']}"
                
                # Draw line
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color=rel['color'], width=rel['width'], dash=rel['dash']),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
                
                # Add label for parent-child
                if rel['type'] == 'Parent-Child':
                    mid_x = (x1 + x2) / 2
                    mid_y = (y1 + y2) / 2
                    
                    fig.add_trace(go.Scatter(
                        x=[mid_x],
                        y=[mid_y],
                        mode='text',
                        text=['Mâ†’C'],
                        textfont=dict(size=9, color='#E74C3C', family='Arial Black'),
                        hoverinfo='skip',
                        showlegend=False
                    ))
        
        # Draw entity rectangles
        for entity_name, (x_center, y_center) in entity_positions.items():
            info = entity_info[entity_name]
            field_count = info['field_count']
            
            # Determine entity type and color
            if info['is_master_account']:
                header_color = '#C0392B'  # Dark red for master
                entity_icon = 'ðŸ‘‘'
                entity_type = 'Master Account'
            elif info['has_master_account_number']:
                header_color = '#E67E22'  # Orange for child
                entity_icon = 'ðŸ“Š'
                entity_type = 'Child Account'
            else:
                header_color = '#3498DB'  # Blue for standard
                entity_icon = 'ðŸ“‹'
                entity_type = 'Entity'
            
            # Rectangle dimensions
            rect_width = 2.0
            rect_height = 1.0
            
            # Coordinates
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            # Border
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            # Header
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor=header_color,
                layer='below'
            )
            
            # Divider
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            # Entity name
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=11, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Field count
            field_info = f"{entity_icon} {field_count} fields"
            
            hover_info = f"<b>{entity_name}</b><br>"
            hover_info += f"Type: {entity_type}<br>"
            hover_info += f"Fields: {field_count}<br>"
            if info['has_account_number']:
                hover_info += "âœ“ ACCOUNT_NUMBER<br>"
            if info['has_master_account_number']:
                hover_info += "âœ“ MASTER_ACCOUNT_NUMBER<br>"
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[field_info],
                textfont=dict(size=9, color='#2C3E50'),
                hoverinfo='text',
                hovertext=hover_info,
                showlegend=False
            ))
        
        # Legend
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#E74C3C', width=4),
            name='Master â†’ Child (MASTER_ACCOUNT_NUMBER)'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#95A5A6', width=2, dash='dash'),
            name='Shared Key Fields'
        ))
        
        # Layout
        fig.update_layout(
            title=dict(
                text="ðŸ“Š Entity Relationship Diagram<br><sub>ðŸ‘‘ Master Account | ðŸ“Š Child Accounts | ðŸ“‹ Other Entities</sub>",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-1, 11]),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-1, 7]),
            height=600,
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=120, b=80),
            showlegend=True,
            legend=dict(
                x=0.5, y=-0.12, xanchor='center', yanchor='top',
                orientation='h', bgcolor='rgba(255,255,255,0.9)',
                bordercolor='#2C3E50', borderwidth=1
            )
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Analyze each entity's fields
        entity_info = {}
        for entity_name, entity_df in entity_models.items():
            # Count total fields
            field_count = len(entity_df)
            
            # Find source field column
            source_col = None
            for col in entity_df.columns:
                if 'source' in col.lower() and 'field' in col.lower():
                    source_col = col
                    break
            
            # Get all field names
            field_names = []
            if source_col:
                field_names = entity_df[source_col].dropna().astype(str).tolist()
            
            # Check for key relationship fields
            has_account_number = False
            has_master_account = False
            has_customer_id = False
            
            for field in field_names:
                field_upper = field.upper()
                if 'ACCOUNT' in field_upper and 'NUMBER' in field_upper and 'MASTER' not in field_upper:
                    has_account_number = True
                if 'MASTER' in field_upper and 'ACCOUNT' in field_upper:
                    has_master_account = True
                if 'CUSTOMER' in field_upper and 'ID' in field_upper:
                    has_customer_id = True
            
            entity_info[entity_name] = {
                'field_count': field_count,
                'field_names': field_names,
                'has_account_number': has_account_number,
                'has_master_account': has_master_account,
                'has_customer_id': has_customer_id,
                'is_master': 'MASTER' in entity_name.upper() or 'PARENT' in entity_name.upper()
            }
        
        # Build relationships based on field patterns
        relationships = []
        
        # Pattern 1: Master Account â†’ Child Account relationship
        # Entities with MASTER_ACCOUNT_NUMBER are children of master account entity
        master_entities = [e for e in entities if entity_info[e]['is_master']]
        child_entities = [e for e in entities if entity_info[e]['has_master_account'] and not entity_info[e]['is_master']]
        
        for master_entity in master_entities:
            for child_entity in child_entities:
                if master_entity != child_entity:
                    relationships.append({
                        'from_entity': master_entity,
                        'to_entity': child_entity,
                        'relationship_type': 'Parent-Child',
                        'key_field': 'MASTER_ACCOUNT_NUMBER',
                        'description': f'{master_entity} (Parent) â†’ {child_entity} (Child)'
                    })
        
        # Pattern 2: Account Number relationships (entities sharing account number)
        entities_with_account = [e for e in entities if entity_info[e]['has_account_number']]
        
        for i, entity1 in enumerate(entities_with_account):
            for entity2 in entities_with_account[i+1:]:
                # Find common fields between entities
                fields1 = set([f.upper() for f in entity_info[entity1]['field_names']])
                fields2 = set([f.upper() for f in entity_info[entity2]['field_names']])
                common = fields1 & fields2
                
                # Filter for key fields
                key_fields = [f for f in common if any(x in f for x in ['ACCOUNT', 'CUSTOMER', 'ID', 'NUMBER', 'KEY'])]
                
                if key_fields:
                    # Check if it's not already a parent-child relationship
                    is_parent_child = any(
                        (r['from_entity'] == entity1 and r['to_entity'] == entity2) or
                        (r['from_entity'] == entity2 and r['to_entity'] == entity1)
                        for r in relationships if r['relationship_type'] == 'Parent-Child'
                    )
                    
                    if not is_parent_child:
                        relationships.append({
                            'from_entity': entity1,
                            'to_entity': entity2,
                            'relationship_type': 'Related',
                            'key_field': key_fields[0] if key_fields else 'ACCOUNT_NUMBER',
                            'description': f'Shared: {", ".join(key_fields[:3])}'
                        })
        
        # Pattern 3: Customer relationships
        customer_entities = [e for e in entities if 'CUSTOMER' in e.upper()]
        entities_with_customer_id = [e for e in entities if entity_info[e]['has_customer_id']]
        
        for customer_entity in customer_entities:
            for other_entity in entities_with_customer_id:
                if customer_entity != other_entity:
                    # Check if not already related
                    is_related = any(
                        (r['from_entity'] == customer_entity and r['to_entity'] == other_entity) or
                        (r['from_entity'] == other_entity and r['to_entity'] == customer_entity)
                        for r in relationships
                    )
                    
                    if not is_related:
                        relationships.append({
                            'from_entity': customer_entity,
                            'to_entity': other_entity,
                            'relationship_type': 'Customer Link',
                            'key_field': 'CUSTOMER_ID',
                            'description': f'{customer_entity} â†’ {other_entity} (CUSTOMER_ID)'
                        })
        
        # Layout entities in a grid
        import math
        n_entities = len(entities)
        n_cols = min(4, math.ceil(math.sqrt(n_entities)))
        n_rows = math.ceil(n_entities / n_cols)
        
        # Entity positions (center of each rectangle)
        entity_positions = {}
        entity_idx = 0
        for row in range(n_rows):
            for col in range(n_cols):
                if entity_idx < n_entities:
                    entity_name = entities[entity_idx]
                    x = col * 3.5
                    y = (n_rows - 1 - row) * 3
                    entity_positions[entity_name] = (x, y)
                    entity_idx += 1
        
        fig = go.Figure()
        
        # Draw relationship lines with different styles
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Line style based on relationship type
                if rel['relationship_type'] == 'Parent-Child':
                    line_color = '#E74C3C'  # Red for parent-child
                    line_width = 4
                    line_dash = 'solid'
                    label = 'P-C'
                elif rel['relationship_type'] == 'Customer Link':
                    line_color = '#9B59B6'  # Purple for customer links
                    line_width = 3
                    line_dash = 'solid'
                    label = 'CUST'
                else:
                    line_color = '#3498DB'  # Blue for related
                    line_width = 2
                    line_dash = 'dash'
                    label = None
                
                # Create hover text
                hover_text = f"<b>{rel['relationship_type']}</b><br>"
                hover_text += f"{from_entity} â†’ {to_entity}<br>"
                hover_text += f"Key: {rel['key_field']}"
                
                # Draw line
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color=line_color, width=line_width, dash=line_dash),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
                
                # Add relationship label for important relationships
                if label:
                    mid_x = (x1 + x2) / 2
                    mid_y = (y1 + y2) / 2
                    
                    fig.add_trace(go.Scatter(
                        x=[mid_x],
                        y=[mid_y],
                        mode='text',
                        text=[label],
                        textfont=dict(size=9, color=line_color, family='Arial Black'),
                        hoverinfo='skip',
                        showlegend=False
                    ))
        
        # Draw entity rectangles
        for entity_name in entities:
            if entity_name not in entity_positions:
                continue
                
            x_center, y_center = entity_positions[entity_name]
            info = entity_info[entity_name]
            field_count = info['field_count']
            
            # Determine entity type for color coding
            is_master = info['is_master']
            has_master = info['has_master_account']
            
            # Color based on entity type
            if is_master:
                header_color = '#E74C3C'  # Red for master/parent
                entity_icon = 'ðŸ‘‘'
            elif has_master:
                header_color = '#F39C12'  # Orange for child
                entity_icon = 'ðŸ“Š'
            elif 'CUSTOMER' in entity_name.upper():
                header_color = '#9B59B6'  # Purple for customer
                entity_icon = 'ðŸ‘¤'
            else:
                header_color = '#3498DB'  # Blue for regular
                entity_icon = 'ðŸ“‹'
            
            # Rectangle dimensions
            rect_width = 1.8
            rect_height = 0.9
            
            # Coordinates
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            # Add rectangle border
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            # Add header rectangle
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor=header_color,
                layer='below'
            )
            
            # Add horizontal divider
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            # Add entity name (header)
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=11, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Add field count with icon (body)
            entity_type = 'Master' if is_master else 'Child' if has_master else 'Standard'
            field_info = f"{entity_icon} {field_count} fields"
            
            hover_info = f"<b>{entity_name}</b><br>"
            hover_info += f"Type: {entity_type}<br>"
            hover_info += f"Fields: {field_count}<br>"
            if info['has_account_number']:
                hover_info += "Has: ACCOUNT_NUMBER<br>"
            if info['has_master_account']:
                hover_info += "Has: MASTER_ACCOUNT_NUMBER<br>"
            if info['has_customer_id']:
                hover_info += "Has: CUSTOMER_ID<br>"
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[field_info],
                textfont=dict(size=9, color='#2C3E50'),
                hoverinfo='text',
                hovertext=hover_info,
                showlegend=False
            ))
        
        # Add legend
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#E74C3C', width=4),
            name='Parent-Child (Master Account)'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#9B59B6', width=3),
            name='Customer Link'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#3498DB', width=2, dash='dash'),
            name='Related (Shared Fields)'
        ))
        
        # Update layout
        fig.update_layout(
            title=dict(
                text="ðŸ“Š Entity Relationship Diagram<br><sub>ðŸ‘‘ Master | ðŸ“Š Child | ðŸ‘¤ Customer | ðŸ“‹ Standard</sub>",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-1, n_cols * 3.5]
            ),
            yaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-1, n_rows * 3 + 0.5]
            ),
            height=max(450, n_rows * 250),
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=120, b=80),
            showlegend=True,
            legend=dict(
                x=0.5,
                y=-0.15,
                xanchor='center',
                yanchor='top',
                orientation='h',
                bgcolor='rgba(255,255,255,0.8)',
                bordercolor='#2C3E50',
                borderwidth=1
            )
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None
    """
    Create traditional database-style ERD using Primary Key and Foreign Key relationships
    Reads PK/FK columns from entity model to build proper relationships
    """
    
    if not PLOTLY_AVAILABLE:
        st.warning("âš ï¸ Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Count fields per entity and identify PKs
        entity_info = {}
        for entity_name, entity_df in entity_models.items():
            # Count total fields
            field_count = len(entity_df)
            
            # Find Primary Key column
            pk_col = None
            for col in entity_df.columns:
                col_lower = col.lower()
                if any(x in col_lower for x in ['primary', 'pk', 'key']) and 'foreign' not in col_lower:
                    pk_col = col
                    break
            
            # Get primary keys
            primary_keys = []
            if pk_col:
                primary_keys = entity_df[entity_df[pk_col].notna()][pk_col].tolist()
            
            entity_info[entity_name] = {
                'field_count': field_count,
                'primary_keys': primary_keys,
                'pk_column': pk_col
            }
        
        # Build relationships based on Foreign Keys
        relationships = []
        
        for entity_name, entity_df in entity_models.items():
            # Find Foreign Key column
            fk_col = None
            fk_ref_col = None  # Column that indicates which entity the FK references
            
            for col in entity_df.columns:
                col_lower = col.lower()
                if 'foreign' in col_lower and 'key' in col_lower:
                    fk_col = col
                if 'reference' in col_lower or 'ref' in col_lower:
                    fk_ref_col = col
            
            # If we have FK information, build relationships
            if fk_col:
                for _, row in entity_df.iterrows():
                    fk_value = safe_get(row, fk_col, '')
                    
                    # If FK is marked (Y, Yes, True, etc.)
                    if fk_value and str(fk_value).strip().upper() in ['Y', 'YES', 'TRUE', '1', 'X']:
                        # Get the field name
                        source_field_col = None
                        for col in entity_df.columns:
                            if 'source' in col.lower() and 'field' in col.lower():
                                source_field_col = col
                                break
                        
                        if source_field_col:
                            field_name = safe_get(row, source_field_col, '')
                            
                            # Try to find which entity this FK references
                            referenced_entity = None
                            
                            # Method 1: Check reference column if exists
                            if fk_ref_col:
                                referenced_entity = safe_get(row, fk_ref_col, '')
                            
                            # Method 2: Match field name with PKs in other entities
                            if not referenced_entity:
                                field_name_lower = field_name.lower()
                                for other_entity, info in entity_info.items():
                                    if other_entity != entity_name:
                                        for pk in info['primary_keys']:
                                            pk_lower = str(pk).lower()
                                            # Check if FK field matches PK field
                                            if field_name_lower == pk_lower or \
                                               field_name_lower in pk_lower or \
                                               pk_lower in field_name_lower:
                                                referenced_entity = other_entity
                                                break
                                    if referenced_entity:
                                        break
                            
                            # Method 3: Infer from field name pattern (e.g., CUSTOMER_ID â†’ Customer)
                            if not referenced_entity:
                                # Remove common suffixes
                                base_name = field_name.upper().replace('_ID', '').replace('_KEY', '').replace('_NO', '').replace('_NBR', '')
                                
                                for other_entity in entities:
                                    if other_entity.upper() in base_name or base_name in other_entity.upper():
                                        referenced_entity = other_entity
                                        break
                            
                            # Add relationship if we found the referenced entity
                            if referenced_entity and referenced_entity in entities:
                                # Check if relationship already exists
                                rel_exists = False
                                for rel in relationships:
                                    if (rel['from_entity'] == entity_name and rel['to_entity'] == referenced_entity) or \
                                       (rel['from_entity'] == referenced_entity and rel['to_entity'] == entity_name):
                                        rel['fk_fields'].append(field_name)
                                        rel_exists = True
                                        break
                                
                                if not rel_exists:
                                    relationships.append({
                                        'from_entity': entity_name,
                                        'to_entity': referenced_entity,
                                        'fk_fields': [field_name],
                                        'type': 'FK'
                                    })
        
        # If no FK relationships found, fall back to shared field analysis
        if not relationships:
            for i, entity1 in enumerate(entities):
                for entity2 in entities[i+1:]:
                    if entity1 in entity_models and entity2 in entity_models:
                        df1 = entity_models[entity1]
                        df2 = entity_models[entity2]
                        
                        # Find source field columns
                        source_col1 = None
                        source_col2 = None
                        
                        for col in df1.columns:
                            if 'source' in col.lower() and 'field' in col.lower():
                                source_col1 = col
                                break
                        
                        for col in df2.columns:
                            if 'source' in col.lower() and 'field' in col.lower():
                                source_col2 = col
                                break
                        
                        if source_col1 and source_col2:
                            fields1 = set(df1[source_col1].dropna().astype(str).str.upper())
                            fields2 = set(df2[source_col2].dropna().astype(str).str.upper())
                            
                            common_fields = fields1 & fields2
                            if len(common_fields) > 0:
                                relationships.append({
                                    'from_entity': entity1,
                                    'to_entity': entity2,
                                    'fk_fields': list(common_fields)[:3],
                                    'type': 'Shared'
                                })
        
        # Layout entities in a grid
        import math
        n_entities = len(entities)
        n_cols = min(4, math.ceil(math.sqrt(n_entities)))
        n_rows = math.ceil(n_entities / n_cols)
        
        # Entity positions (center of each rectangle)
        entity_positions = {}
        entity_idx = 0
        for row in range(n_rows):
            for col in range(n_cols):
                if entity_idx < n_entities:
                    entity_name = entities[entity_idx]
                    x = col * 3.5
                    y = (n_rows - 1 - row) * 3
                    entity_positions[entity_name] = (x, y)
                    entity_idx += 1
        
        fig = go.Figure()
        
        # Draw relationship lines with cardinality
        for rel in relationships:
            from_entity = rel['from_entity']
            to_entity = rel['to_entity']
            
            if from_entity in entity_positions and to_entity in entity_positions:
                x1, y1 = entity_positions[from_entity]
                x2, y2 = entity_positions[to_entity]
                
                # Line style based on relationship type
                if rel['type'] == 'FK':
                    line_color = '#E74C3C'  # Red for FK relationships
                    line_width = 3
                    line_dash = 'solid'
                else:
                    line_color = '#BDC3C7'  # Gray for shared fields
                    line_width = 2
                    line_dash = 'dash'
                
                # Create hover text
                hover_text = f"<b>{from_entity} â†’ {to_entity}</b><br>"
                if rel['type'] == 'FK':
                    hover_text += f"Foreign Key Relationship<br>"
                else:
                    hover_text += f"Shared Fields<br>"
                hover_text += f"Fields: {', '.join(rel['fk_fields'][:3])}"
                if len(rel['fk_fields']) > 3:
                    hover_text += f" (+{len(rel['fk_fields']) - 3} more)"
                
                # Draw line
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color=line_color, width=line_width, dash=line_dash),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
                
                # Add cardinality markers for FK relationships
                if rel['type'] == 'FK':
                    # Calculate midpoint
                    mid_x = (x1 + x2) / 2
                    mid_y = (y1 + y2) / 2
                    
                    # Add relationship type indicator
                    fig.add_trace(go.Scatter(
                        x=[mid_x],
                        y=[mid_y],
                        mode='text',
                        text=['FK'],
                        textfont=dict(size=8, color='#E74C3C', family='Arial Black'),
                        hoverinfo='skip',
                        showlegend=False
                    ))
        
        # Draw entity rectangles
        for entity_name in entities:
            if entity_name not in entity_positions:
                continue
                
            x_center, y_center = entity_positions[entity_name]
            field_count = entity_info[entity_name]['field_count']
            pk_count = len(entity_info[entity_name]['primary_keys'])
            
            # Rectangle dimensions
            rect_width = 1.8
            rect_height = 0.9
            
            # Coordinates
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            # Add rectangle border
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            # Add header rectangle (darker)
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor="#3498DB",
                layer='below'
            )
            
            # Add horizontal divider
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            # Add entity name (header)
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=12, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Add field count with PK info (body)
            field_info = f"ðŸ“‹ {field_count} fields"
            if pk_count > 0:
                field_info += f" | ðŸ”‘ {pk_count} PK"
            
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[field_info],
                textfont=dict(size=9, color='#2C3E50'),
                hoverinfo='text',
                hovertext=f"<b>{entity_name}</b><br>{field_count} fields<br>{pk_count} primary keys<br>Click entity below to view details",
                showlegend=False
            ))
        
        # Add legend
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#E74C3C', width=3),
            name='FK Relationship'
        ))
        
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#BDC3C7', width=2, dash='dash'),
            name='Shared Fields'
        ))
        
        # Update layout
        fig.update_layout(
            title=dict(
                text="ðŸ“Š Entity Relationship Diagram (PK/FK Relationships)",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-1, n_cols * 3.5]
            ),
            yaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-1, n_rows * 3 + 0.5]
            ),
            height=max(450, n_rows * 250),
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=100, b=60),
            showlegend=True,
            legend=dict(
                x=0.5,
                y=-0.1,
                xanchor='center',
                yanchor='top',
                orientation='h'
            )
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None

# ========================================================
# FIELD LINEAGE DIAGRAM
# ========================================================

def create_field_lineage_diagram(entity_name, entity_df):
    """
    Create field-level lineage visualization
    Shows: Source Field â†’ [Transformation] â†’ DW Column
    """
    
    if not PLOTLY_AVAILABLE or entity_df is None or len(entity_df) == 0:
        return None
    
    try:
        # Detect column names
        source_col = None
        target_col = None
        desc_col = None
        
        for col in entity_df.columns:
            col_lower = col.lower()
            
            if not source_col and any(x in col_lower for x in ['source', 'field']) and 'dw' not in col_lower:
                source_col = col
            elif not target_col and any(x in col_lower for x in ['dw', 'warehouse', 'target', 'map']):
                target_col = col
            elif not desc_col and any(x in col_lower for x in ['desc', 'description']):
                desc_col = col
        
        if not source_col or not target_col:
            st.warning("âš ï¸ Could not detect source and target field columns")
            st.write("Available columns:", list(entity_df.columns))
            return None
        
        st.info(f"Using: **{source_col}** â†’ **{target_col}**")
        
        # Create visualization
        fig = go.Figure()
        
        num_fields = min(len(entity_df), 15)  # Show max 15
        
        for idx, (_, row) in enumerate(entity_df.head(15).iterrows()):
            source_field = safe_get(row, source_col, f"Field_{idx}")
            target_field = safe_get(row, target_col, f"DW_{idx}")
            description = safe_get(row, desc_col, "") if desc_col else ""
            
            y_pos = 15 - idx
            
            # Source field (left)
            fig.add_trace(go.Scatter(
                x=[0],
                y=[y_pos],
                mode='markers+text',
                marker=dict(size=35, color='#2196F3', line=dict(width=2, color='white')),
                text=[source_field[:25]],
                textposition="middle left",
                textfont=dict(size=9),
                hovertext=f"<b>Source:</b> {source_field}<br><b>Description:</b> {description}",
                hoverinfo='text',
                showlegend=False
            ))
            
            # Target field (right)
            fig.add_trace(go.Scatter(
                x=[2],
                y=[y_pos],
                mode='markers+text',
                marker=dict(size=35, color='#4CAF50', line=dict(width=2, color='white')),
                text=[target_field[:25]],
                textposition="middle right",
                textfont=dict(size=9),
                hovertext=f"<b>DW Column:</b> {target_field}",
                hoverinfo='text',
                showlegend=False
            ))
            
            # Arrow
            fig.add_annotation(
                x=0.15, y=y_pos,
                ax=1.85, ay=y_pos,
                xref='x', yref='y',
                axref='x', ayref='y',
                showarrow=True,
                arrowhead=2,
                arrowsize=1,
                arrowwidth=2,
                arrowcolor='#888'
            )
        
        fig.update_layout(
            title=f"ðŸ”„ Field Lineage: {entity_name}",
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-0.8, 2.8]),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            height=max(500, num_fields * 40),
            margin=dict(l=200, r=200, t=60, b=20),
            plot_bgcolor='white'
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating field lineage: {e}")
        return None

# ========================================================
# ENTITY RELATIONSHIP DIAGRAM (ERD)
# ========================================================


# ========================================================
# ENTITY EXPLORER UI
# ========================================================

def render_entity_explorer(entity_matrix_df, entity_models, selected_entity=None):
    """
    Main Entity Explorer UI
    Can be called from main app or run standalone
    
    Args:
        entity_matrix_df: DataFrame with entity matrix
        entity_models: Dict of entity DataFrames
        selected_entity: Optional - entity to show details for
    """
    
    st.markdown("## ðŸ“š Entity Model Explorer")
    
    if entity_matrix_df is None or not entity_models:
        st.warning("âš ï¸ No entity models loaded. Upload Entity Model Reference file.")
        return None
    
    # Tabs
    tab1, tab2, tab3 = st.tabs(["ðŸ“Š Overview", "ðŸ” Entity Detail", "ðŸ”Ž Field Search"])
    
    with tab1:
        st.subheader("Entity Relationship Diagram")
        
        with st.expander("â„¹ï¸ How to use", expanded=False):
            st.markdown("""
            - **Hover** over nodes to see entity details
            - **Larger nodes** = more fields
            - **Connected nodes** = related entities
            - **Click** entity name in list below to view details
            """)
        
        # Generate ERD
        erd_fig = create_entity_relationship_diagram(entity_matrix_df, entity_models)
        if erd_fig:
            st.plotly_chart(erd_fig, use_container_width=True)
        
        st.markdown("---")
        
        # Entity list
        st.subheader(f"ðŸ“‹ All Entities ({len(entity_models)})")
        
        col1, col2, col3 = st.columns(3)
        
        for idx, (entity_name, entity_df) in enumerate(sorted(entity_models.items())):
            with [col1, col2, col3][idx % 3]:
                with st.container():
                    st.markdown(f"""
                    <div style="background: white; padding: 1rem; border-radius: 10px; 
                                border-left: 4px solid #9C27B0; margin: 0.5rem 0;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0; color: #9C27B0;">{entity_name}</h4>
                        <p style="margin: 0.5rem 0 0 0; color: #666;">
                            {len(entity_df)} fields
                        </p>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    if st.button(f"View Details â†’", key=f"view_{entity_name}"):
                        # Switch to Entity Detail tab
                        return entity_name
    
    with tab2:
        st.subheader("ðŸ” Entity Details")
        
        # Entity selector
        entity_list = sorted(entity_models.keys())
        
        if selected_entity and selected_entity in entity_list:
            default_idx = entity_list.index(selected_entity)
        else:
            default_idx = 0
        
        selected = st.selectbox(
            "Select Entity:",
            entity_list,
            index=default_idx,
            key="entity_selector"
        )
        
        if selected:
            entity_df = entity_models[selected]
            
            st.markdown(f"### ðŸ“Š {selected}")
            st.write(f"**Total Fields:** {len(entity_df)}")
            
            # Field lineage diagram
            st.markdown("#### ðŸ”„ Field Lineage Visualization")
            lineage_fig = create_field_lineage_diagram(selected, entity_df)
            if lineage_fig:
                st.plotly_chart(lineage_fig, use_container_width=True)
            
            st.markdown("---")
            
            # Field mapping table
            st.markdown("#### ðŸ“‹ Complete Field Mapping")
            
            # Display the dataframe
            st.dataframe(
                entity_df,
                use_container_width=True,
                height=400
            )
            
            # Export option
            col1, col2 = st.columns([1, 3])
            with col1:
                csv = entity_df.to_csv(index=False)
                st.download_button(
                    "ðŸ“¥ Export CSV",
                    csv,
                    f"{selected}_fields.csv",
                    "text/csv"
                )
    
    with tab3:
        st.subheader("ðŸ”Ž Field Search")
        
        st.write("Search across all entities for specific fields")
        
        search_term = st.text_input("Search for field name:", "")
        
        search_type = st.radio(
            "Search in:",
            ["Source Fields", "DW Columns", "Descriptions", "All"],
            horizontal=True
        )
        
        if search_term:
            results = []
            
            for entity_name, entity_df in entity_models.items():
                # Search based on type
                matches = pd.DataFrame()
                
                for col in entity_df.columns:
                    col_lower = col.lower()
                    search_lower = search_term.lower()
                    
                    if search_type == "All" or \
                       (search_type == "Source Fields" and 'source' in col_lower) or \
                       (search_type == "DW Columns" and any(x in col_lower for x in ['dw', 'warehouse', 'target'])) or \
                       (search_type == "Descriptions" and 'desc' in col_lower):
                        
                        mask = entity_df[col].astype(str).str.contains(search_lower, case=False, na=False)
                        if mask.any():
                            temp = entity_df[mask].copy()
                            temp['Entity'] = entity_name
                            results.append(temp)
            
            if results:
                combined = pd.concat(results, ignore_index=True)
                st.success(f"âœ… Found {len(combined)} matches across {len(results)} entities")
                
                st.dataframe(combined, use_container_width=True, height=400)
            else:
                st.info(f"No matches found for '{search_term}'")
    
    return None

# ========================================================
# STANDALONE MODE
# ========================================================

if __name__ == "__main__":
    st.set_page_config(
        page_title="Entity Model Explorer",
        page_icon="ðŸ“š",
        layout="wide"
    )
    
    st.title("ðŸ“š Entity Model Explorer - Standalone")
    
    # File uploader
    uploaded_file = st.file_uploader(
        "Upload Entity Model Reference Excel",
        type=['xlsx', 'xls'],
        help="Excel file with Entity Matrix sheet and individual entity sheets"
    )
    
    if uploaded_file:
        # Load entity models
        entity_matrix, entity_models = load_entity_model_reference(uploaded_file)
        
        if entity_matrix is not None and entity_models:
            # Render explorer
            selected = render_entity_explorer(entity_matrix, entity_models)
            
            # Handle entity selection (for standalone mode, just re-render)
            if selected:
                st.rerun()
    else:
        st.info("ðŸ‘† Upload your Entity Model Reference Excel file to get started")
        
        with st.expander("ðŸ“‹ Expected File Format", expanded=True):
            st.markdown("""
            **Sheet 1: "Entity Matrix"**
            - List of all entities/tables
            - Optional: relationships between entities
            
            **Other Sheets: Individual Entity Models**
            - Sheet name = Entity name (e.g., "Account", "Transaction")
            - Columns should include:
              - Source field names
              - Field descriptions
              - Data warehouse column names
              
            **Example:**
            ```
            Sheet: Account
            | Source Field    | Field Description          | DW Column Name |
            |-----------------|----------------------------|----------------|
            | ACCOUNT_NUMBER  | Unique account identifier  | ACCOUNT_NUMBER |
            | CUSTOMER_NAME   | Customer full name         | CUSTOMER_NAME  |
            ```
            """)
