"""
========================================================
ENTITY MODEL EXPLORER - Modular Component
========================================================
Can be imported and used by main Data Explorer
or run standalone

Features:
- Load Entity Model Reference Excel
- Entity Relationship Diagrams
- Field-level lineage (Source ‚Üí DW)
- Search entities and fields
- Cross-reference with interfaces
========================================================
"""

import streamlit as st
import pandas as pd
import os
from collections import defaultdict

# Visualization
try:
    import plotly.graph_objects as go
    import networkx as nx
    PLOTLY_AVAILABLE = True
except:
    PLOTLY_AVAILABLE = False

# ========================================================
# UTILITY FUNCTIONS
# ========================================================

def clean_column_name(col):
    """Clean column names for consistent access"""
    return str(col).strip().lower().replace(" ", "_").replace("/", "_").replace("-", "_").replace("(", "").replace(")", "").strip("_")

def safe_get(row, column, default=""):
    """Safely get value from row"""
    try:
        val = row.get(column, default) if isinstance(row, dict) else getattr(row, column, default)
        return val if pd.notna(val) and str(val) != 'nan' and str(val) != '' else default
    except:
        return default

# ========================================================
# ENTITY MODEL LOADER
# ========================================================

def load_entity_model_reference(file):
    """
    Load Entity Model Reference Excel
    
    Expected structure:
    - Sheet 1: "Entity Matrix" - List of all entities and relationships
    - Other Sheets: Individual entity models (e.g., "Account", "Transaction")
      - Columns: Source Field, Field Description, DW Column Name (or similar)
    
    Returns:
        entity_matrix_df: DataFrame with entity matrix
        entity_models: Dict of {entity_name: DataFrame with field mappings}
    """
    
    st.info("üìö Loading Entity Model Reference...")
    
    try:
        # Read all sheet names
        excel_file = pd.ExcelFile(file)
        sheet_names = excel_file.sheet_names
        
        st.write(f"‚úÖ Found {len(sheet_names)} sheets")
        
        # First sheet is Entity Matrix
        entity_matrix = None
        matrix_sheet_name = None
        
        for sheet in ["Entity Matrix", "entity matrix", "Matrix", "matrix", "Sheet1"]:
            if sheet in sheet_names:
                entity_matrix = pd.read_excel(file, sheet_name=sheet)
                matrix_sheet_name = sheet
                st.success(f"‚úÖ Loaded Entity Matrix from sheet: '{sheet}'")
                break
        
        if entity_matrix is None:
            # Use first sheet
            entity_matrix = pd.read_excel(file, sheet_name=0)
            matrix_sheet_name = sheet_names[0]
            st.info(f"‚ÑπÔ∏è Using first sheet as Entity Matrix: '{matrix_sheet_name}'")
        
        # Clean entity matrix
        entity_matrix.columns = [clean_column_name(col) for col in entity_matrix.columns]
        entity_matrix = entity_matrix.dropna(axis=1, how='all')
        entity_matrix = entity_matrix.loc[:, ~entity_matrix.columns.str.contains("^unnamed", case=False)]
        
        # Show detected columns
        with st.expander("üìã Entity Matrix Columns Detected", expanded=False):
            st.write("Columns found:", list(entity_matrix.columns))
            st.write(f"Rows: {len(entity_matrix)}")
        
        # Load all other sheets as entity models
        entity_models = {}
        
        for sheet_name in sheet_names:
            # Skip the matrix sheet
            if sheet_name == matrix_sheet_name:
                continue
                
            try:
                df = pd.read_excel(file, sheet_name=sheet_name)
                
                # Clean columns
                df.columns = [clean_column_name(col) for col in df.columns]
                df = df.dropna(axis=1, how='all')
                df = df.loc[:, ~df.columns.str.contains("^unnamed", case=False)]
                
                # Remove empty rows
                df = df.dropna(how='all')
                
                # Clean strings
                for col in df.select_dtypes(include=['object']).columns:
                    df[col] = df[col].astype(str).str.strip()
                    df[col] = df[col].replace({'nan': '', 'None': '', 'NaN': ''})
                
                # Store entity model
                entity_models[sheet_name] = df
                st.success(f"‚úÖ Loaded entity: **{sheet_name}** ({len(df)} fields)")
                
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Could not load sheet '{sheet_name}': {e}")
        
        st.success(f"‚úÖ **Total: {len(entity_models)} entity models loaded**")
        
        return entity_matrix, entity_models
        
    except Exception as e:
        st.error(f"‚ùå Error loading Entity Model Reference: {e}")
        return None, {}

# ========================================================
# ENTITY RELATIONSHIP DIAGRAM
# ========================================================

def create_entity_relationship_diagram(entity_matrix_df, entity_models):
    """
    Create traditional database-style ERD with entities as rectangles/tables
    Shows entities with field counts in classic ERD format
    """
    
    if not PLOTLY_AVAILABLE:
        st.warning("‚ö†Ô∏è Plotly not available. Install: pip install plotly networkx")
        return None
    
    try:
        # Get all entities
        entities = list(entity_models.keys()) if entity_models else []
        
        if not entities:
            return None
        
        # Count fields per entity
        entity_field_counts = {}
        for entity_name, entity_df in entity_models.items():
            entity_field_counts[entity_name] = len(entity_df)
        
        # Find relationships (entities that share field names)
        relationships = []
        for i, entity1 in enumerate(entities):
            for entity2 in entities[i+1:]:
                if entity1 in entity_models and entity2 in entity_models:
                    df1 = entity_models[entity1]
                    df2 = entity_models[entity2]
                    
                    # Find source field columns
                    source_col1 = None
                    source_col2 = None
                    
                    for col in df1.columns:
                        if 'source' in col.lower() and 'field' in col.lower():
                            source_col1 = col
                            break
                    
                    for col in df2.columns:
                        if 'source' in col.lower() and 'field' in col.lower():
                            source_col2 = col
                            break
                    
                    if source_col1 and source_col2:
                        fields1 = set(df1[source_col1].dropna().astype(str).str.lower())
                        fields2 = set(df2[source_col2].dropna().astype(str).str.lower())
                        
                        common_fields = fields1 & fields2
                        if len(common_fields) > 0:
                            relationships.append({
                                'entity1': entity1,
                                'entity2': entity2,
                                'common_fields': len(common_fields),
                                'field_names': list(common_fields)[:3]  # First 3 for tooltip
                            })
        
        # Layout entities in a grid
        import math
        n_entities = len(entities)
        n_cols = min(4, math.ceil(math.sqrt(n_entities)))  # Max 4 columns
        n_rows = math.ceil(n_entities / n_cols)
        
        # Entity positions (center of each rectangle)
        entity_positions = {}
        entity_idx = 0
        for row in range(n_rows):
            for col in range(n_cols):
                if entity_idx < n_entities:
                    entity_name = entities[entity_idx]
                    x = col * 3.5
                    y = (n_rows - 1 - row) * 3  # Top to bottom
                    entity_positions[entity_name] = (x, y)
                    entity_idx += 1
        
        fig = go.Figure()
        
        # Draw relationship lines first (behind rectangles)
        for rel in relationships:
            if rel['entity1'] in entity_positions and rel['entity2'] in entity_positions:
                x1, y1 = entity_positions[rel['entity1']]
                x2, y2 = entity_positions[rel['entity2']]
                
                # Line width based on number of common fields
                line_width = min(1 + rel['common_fields'] / 5, 4)
                
                # Create hover text with field names
                hover_text = f"{rel['common_fields']} shared fields"
                if rel['field_names']:
                    hover_text += f"<br>e.g., {', '.join(rel['field_names'][:3])}"
                
                fig.add_trace(go.Scatter(
                    x=[x1, x2],
                    y=[y1, y2],
                    mode='lines',
                    line=dict(color='#BDC3C7', width=line_width),
                    hoverinfo='text',
                    hovertext=hover_text,
                    showlegend=False
                ))
        
        # Draw entity rectangles (traditional database table style)
        for entity_name in entities:
            if entity_name not in entity_positions:
                continue
                
            x_center, y_center = entity_positions[entity_name]
            field_count = entity_field_counts.get(entity_name, 0)
            
            # Rectangle dimensions
            rect_width = 1.8
            rect_height = 0.9
            
            # Coordinates
            x0 = x_center - rect_width / 2
            x1 = x_center + rect_width / 2
            y0 = y_center - rect_height / 2
            y1 = y_center + rect_height / 2
            
            # Add rectangle border
            fig.add_shape(
                type="rect",
                x0=x0, y0=y0, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=3),
                fillcolor="#ECF0F1",
                layer='below'
            )
            
            # Add header rectangle (darker)
            fig.add_shape(
                type="rect",
                x0=x0, y0=y_center, x1=x1, y1=y1,
                line=dict(color="#2C3E50", width=0),
                fillcolor="#3498DB",
                layer='below'
            )
            
            # Add horizontal divider
            fig.add_shape(
                type="line",
                x0=x0, y0=y_center, x1=x1, y1=y_center,
                line=dict(color="#2C3E50", width=2)
            )
            
            # Add entity name (header - white text on blue)
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center + rect_height / 4],
                mode='text',
                text=[f"<b>{entity_name}</b>"],
                textfont=dict(size=12, color='white', family='Arial Black'),
                hoverinfo='skip',
                showlegend=False
            ))
            
            # Add field count (body - dark text on light gray)
            fig.add_trace(go.Scatter(
                x=[x_center],
                y=[y_center - rect_height / 4],
                mode='text',
                text=[f"üìã {field_count} fields"],
                textfont=dict(size=10, color='#2C3E50'),
                hoverinfo='text',
                hovertext=f"<b>{entity_name}</b><br>{field_count} fields<br>Click entity name below to view details",
                showlegend=False
            ))
        
        # Update layout for clean ERD look
        fig.update_layout(
            title=dict(
                text="üìä Entity Relationship Diagram (Traditional ERD Style)",
                x=0.5,
                xanchor='center',
                font=dict(size=16, color='#2C3E50', family='Arial')
            ),
            xaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-1, n_cols * 3.5]
            ),
            yaxis=dict(
                showgrid=False, 
                zeroline=False, 
                showticklabels=False,
                range=[-1, n_rows * 3 + 0.5]
            ),
            height=max(450, n_rows * 250),
            plot_bgcolor='#FFFFFF',
            paper_bgcolor='#F8F9FA',
            hovermode='closest',
            margin=dict(l=40, r=40, t=100, b=40)
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating ERD: {e}")
        import traceback
        st.error(traceback.format_exc())
        return None

# ========================================================
# FIELD LINEAGE DIAGRAM
# ========================================================

def create_field_lineage_diagram(entity_name, entity_df):
    """
    Create field-level lineage visualization
    Shows: Source Field ‚Üí [Transformation] ‚Üí DW Column
    """
    
    if not PLOTLY_AVAILABLE or entity_df is None or len(entity_df) == 0:
        return None
    
    try:
        # Detect column names
        source_col = None
        target_col = None
        desc_col = None
        
        for col in entity_df.columns:
            col_lower = col.lower()
            
            if not source_col and any(x in col_lower for x in ['source', 'field']) and 'dw' not in col_lower:
                source_col = col
            elif not target_col and any(x in col_lower for x in ['dw', 'warehouse', 'target', 'map']):
                target_col = col
            elif not desc_col and any(x in col_lower for x in ['desc', 'description']):
                desc_col = col
        
        if not source_col or not target_col:
            st.warning("‚ö†Ô∏è Could not detect source and target field columns")
            st.write("Available columns:", list(entity_df.columns))
            return None
        
        st.info(f"Using: **{source_col}** ‚Üí **{target_col}**")
        
        # Create visualization
        fig = go.Figure()
        
        num_fields = min(len(entity_df), 15)  # Show max 15
        
        for idx, (_, row) in enumerate(entity_df.head(15).iterrows()):
            source_field = safe_get(row, source_col, f"Field_{idx}")
            target_field = safe_get(row, target_col, f"DW_{idx}")
            description = safe_get(row, desc_col, "") if desc_col else ""
            
            y_pos = 15 - idx
            
            # Source field (left)
            fig.add_trace(go.Scatter(
                x=[0],
                y=[y_pos],
                mode='markers+text',
                marker=dict(size=35, color='#2196F3', line=dict(width=2, color='white')),
                text=[source_field[:25]],
                textposition="middle left",
                textfont=dict(size=9),
                hovertext=f"<b>Source:</b> {source_field}<br><b>Description:</b> {description}",
                hoverinfo='text',
                showlegend=False
            ))
            
            # Target field (right)
            fig.add_trace(go.Scatter(
                x=[2],
                y=[y_pos],
                mode='markers+text',
                marker=dict(size=35, color='#4CAF50', line=dict(width=2, color='white')),
                text=[target_field[:25]],
                textposition="middle right",
                textfont=dict(size=9),
                hovertext=f"<b>DW Column:</b> {target_field}",
                hoverinfo='text',
                showlegend=False
            ))
            
            # Arrow
            fig.add_annotation(
                x=0.15, y=y_pos,
                ax=1.85, ay=y_pos,
                xref='x', yref='y',
                axref='x', ayref='y',
                showarrow=True,
                arrowhead=2,
                arrowsize=1,
                arrowwidth=2,
                arrowcolor='#888'
            )
        
        fig.update_layout(
            title=f"üîÑ Field Lineage: {entity_name}",
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[-0.8, 2.8]),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            height=max(500, num_fields * 40),
            margin=dict(l=200, r=200, t=60, b=20),
            plot_bgcolor='white'
        )
        
        return fig
        
    except Exception as e:
        st.error(f"Error creating field lineage: {e}")
        return None

# ========================================================
# ENTITY RELATIONSHIP DIAGRAM (ERD)
# ========================================================


# ========================================================
# ENTITY EXPLORER UI
# ========================================================

def render_entity_explorer(entity_matrix_df, entity_models, selected_entity=None):
    """
    Main Entity Explorer UI
    Can be called from main app or run standalone
    
    Args:
        entity_matrix_df: DataFrame with entity matrix
        entity_models: Dict of entity DataFrames
        selected_entity: Optional - entity to show details for
    """
    
    st.markdown("## üìö Entity Model Explorer")
    
    if entity_matrix_df is None or not entity_models:
        st.warning("‚ö†Ô∏è No entity models loaded. Upload Entity Model Reference file.")
        return None
    
    # Tabs
    tab1, tab2, tab3 = st.tabs(["üìä Overview", "üîç Entity Detail", "üîé Field Search"])
    
    with tab1:
        st.subheader("Entity Relationship Diagram")
        
        with st.expander("‚ÑπÔ∏è How to use", expanded=False):
            st.markdown("""
            - **Hover** over nodes to see entity details
            - **Larger nodes** = more fields
            - **Connected nodes** = related entities
            - **Click** entity name in list below to view details
            """)
        
        # Generate ERD
        erd_fig = create_entity_relationship_diagram(entity_matrix_df, entity_models)
        if erd_fig:
            st.plotly_chart(erd_fig, use_container_width=True)
        
        st.markdown("---")
        
        # Entity list
        st.subheader(f"üìã All Entities ({len(entity_models)})")
        
        col1, col2, col3 = st.columns(3)
        
        for idx, (entity_name, entity_df) in enumerate(sorted(entity_models.items())):
            with [col1, col2, col3][idx % 3]:
                with st.container():
                    st.markdown(f"""
                    <div style="background: white; padding: 1rem; border-radius: 10px; 
                                border-left: 4px solid #9C27B0; margin: 0.5rem 0;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0; color: #9C27B0;">{entity_name}</h4>
                        <p style="margin: 0.5rem 0 0 0; color: #666;">
                            {len(entity_df)} fields
                        </p>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    if st.button(f"View Details ‚Üí", key=f"view_{entity_name}"):
                        # Switch to Entity Detail tab
                        return entity_name
    
    with tab2:
        st.subheader("üîç Entity Details")
        
        # Entity selector
        entity_list = sorted(entity_models.keys())
        
        if selected_entity and selected_entity in entity_list:
            default_idx = entity_list.index(selected_entity)
        else:
            default_idx = 0
        
        selected = st.selectbox(
            "Select Entity:",
            entity_list,
            index=default_idx,
            key="entity_selector"
        )
        
        if selected:
            entity_df = entity_models[selected]
            
            st.markdown(f"### üìä {selected}")
            st.write(f"**Total Fields:** {len(entity_df)}")
            
            # Field lineage diagram
            st.markdown("#### üîÑ Field Lineage Visualization")
            lineage_fig = create_field_lineage_diagram(selected, entity_df)
            if lineage_fig:
                st.plotly_chart(lineage_fig, use_container_width=True)
            
            st.markdown("---")
            
            # Field mapping table
            st.markdown("#### üìã Complete Field Mapping")
            
            # Display the dataframe
            st.dataframe(
                entity_df,
                use_container_width=True,
                height=400
            )
            
            # Export option
            col1, col2 = st.columns([1, 3])
            with col1:
                csv = entity_df.to_csv(index=False)
                st.download_button(
                    "üì• Export CSV",
                    csv,
                    f"{selected}_fields.csv",
                    "text/csv"
                )
    
    with tab3:
        st.subheader("üîé Field Search")
        
        st.write("Search across all entities for specific fields")
        
        search_term = st.text_input("Search for field name:", "")
        
        search_type = st.radio(
            "Search in:",
            ["Source Fields", "DW Columns", "Descriptions", "All"],
            horizontal=True
        )
        
        if search_term:
            results = []
            
            for entity_name, entity_df in entity_models.items():
                # Search based on type
                matches = pd.DataFrame()
                
                for col in entity_df.columns:
                    col_lower = col.lower()
                    search_lower = search_term.lower()
                    
                    if search_type == "All" or \
                       (search_type == "Source Fields" and 'source' in col_lower) or \
                       (search_type == "DW Columns" and any(x in col_lower for x in ['dw', 'warehouse', 'target'])) or \
                       (search_type == "Descriptions" and 'desc' in col_lower):
                        
                        mask = entity_df[col].astype(str).str.contains(search_lower, case=False, na=False)
                        if mask.any():
                            temp = entity_df[mask].copy()
                            temp['Entity'] = entity_name
                            results.append(temp)
            
            if results:
                combined = pd.concat(results, ignore_index=True)
                st.success(f"‚úÖ Found {len(combined)} matches across {len(results)} entities")
                
                st.dataframe(combined, use_container_width=True, height=400)
            else:
                st.info(f"No matches found for '{search_term}'")
    
    return None

# ========================================================
# STANDALONE MODE
# ========================================================

if __name__ == "__main__":
    st.set_page_config(
        page_title="Entity Model Explorer",
        page_icon="üìö",
        layout="wide"
    )
    
    st.title("üìö Entity Model Explorer - Standalone")
    
    # File uploader
    uploaded_file = st.file_uploader(
        "Upload Entity Model Reference Excel",
        type=['xlsx', 'xls'],
        help="Excel file with Entity Matrix sheet and individual entity sheets"
    )
    
    if uploaded_file:
        # Load entity models
        entity_matrix, entity_models = load_entity_model_reference(uploaded_file)
        
        if entity_matrix is not None and entity_models:
            # Render explorer
            selected = render_entity_explorer(entity_matrix, entity_models)
            
            # Handle entity selection (for standalone mode, just re-render)
            if selected:
                st.rerun()
    else:
        st.info("üëÜ Upload your Entity Model Reference Excel file to get started")
        
        with st.expander("üìã Expected File Format", expanded=True):
            st.markdown("""
            **Sheet 1: "Entity Matrix"**
            - List of all entities/tables
            - Optional: relationships between entities
            
            **Other Sheets: Individual Entity Models**
            - Sheet name = Entity name (e.g., "Account", "Transaction")
            - Columns should include:
              - Source field names
              - Field descriptions
              - Data warehouse column names
              
            **Example:**
            ```
            Sheet: Account
            | Source Field    | Field Description          | DW Column Name |
            |-----------------|----------------------------|----------------|
            | ACCOUNT_NUMBER  | Unique account identifier  | ACCOUNT_NUMBER |
            | CUSTOMER_NAME   | Customer full name         | CUSTOMER_NAME  |
            ```
            """)
